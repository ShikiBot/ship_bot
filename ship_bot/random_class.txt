class Randomize
{
	UInt32 state0 = 1; //начальное состояние параметра 1
	UInt32 state1 = 2; //начальное состояние параметра 2
	float rnd;
	public float mwc1616_M()
	{
		//DateTime.Now.Ticks - текущее время в тиках, state0 >> 16 - побитовый сдвиг вправо на 16 бит, 0xffff - число в 16ричной системе, с которой производится операция коньюнкции
		state0 = 18030 * ((UInt32)((44655 * DateTime.Now.Ticks + 21154) % 79) & 0xffff) + (state0 >> 16); //изменение параметра 1
		state1 = 30903 * (state1 & 0xffff) + (state1 >> 16); //изменение параметра 2
		rnd = (float)Math.Round(((float)((state0 << 16) + (state1 & 0xffff) - 91818513)) / 4228782262, 4); //генерирование числа на основе параметров в промежутке (0;1], округление числа до десятитысячных
		if (Math.Round(rnd, 3) == 0) //костыльный переход к промежутку [0;1]
		{
			rnd = 0;
		}	
		if (rnd > 1) //по идее зарандомленое число не должно быть больше 1, но на всякий случай воткнул проверку
		{
			rnd = mwc1616_M(); //если рандомное число выходит за границы диапазона [0;1], то рандомится новое число
		}
		Thread.Sleep(100); // промежуток бездействия кода в 100 милисекунд, чтобы в цикле не рандомились одинаковые значения рандома подряд
		return rnd;
	}
}